<!DOCTYPE html>
<html lang="{{ .Site.LanguageCode }}">
<head>
    <meta charset="utf-8" />
    <title>{{ .Site.Title }}</title>
    {{ with .Site.Params.description }}<meta name="description" content="{{ . }}">{{ end }}
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="robots" content="all,follow" />
    <meta name="googlebot" content="index,follow,snippet,archive" />

    <!-- Theme's main CSS (we'll override colors, caret, etc.) -->
    <link rel="stylesheet" href="{{ "hugo-theme-console/css/terminal-0.7.4.min.css" | absURL }}">
    <link rel="stylesheet" href="{{ "hugo-theme-console/css/animate-4.1.1.min.css" | absURL }}">
    <link rel="stylesheet" href="{{ "hugo-theme-console/css/console.css" | absURL }}">


    <style>
        body{
            margin: 0 auto;
            font-size: 14px;
            max-width: 800px; /* Restricts width on larger screens */
            font-family: monospace;
        }
        body.terminal {
            background-color: #fff !important;
            color: #000 !important;
        }
        .logo.terminal-prompt::after {
            /* Remove the theme's blinking pseudo-cursor */
            content: none !important;
            animation: none !important;
        }
        .terminal-menu a {
            color: #000 !important;
            text-decoration: none;
        }
        #consoleForm {
            display: inline-block;
            margin-left: 8px;
        }
        #terminalInput {
            display: inline-block;
            min-width: 300px; /* enough for placeholder text */
            white-space: pre;
            outline: none;
            border: none;
            background: none;
            color: #000;
            caret-color: #000; /* visible once user types */
        }
        #terminalInput.placeholder {
            color: #aaa;
            caret-color: transparent;
        }
        /* leftover text in grey (if user typed a prefix of exactly 1 known command) */
        .leftover {
            color: #aaa;
        }
        .terminal-prompt{
            pointer-events: none;
        }
        .line {
            margin-left: 12rem;
            margin-bottom: 0.2em;
        }
        .echo {
            margin-top: 1.0em;
            margin-bottom: 1.0em;
        }
        .edu-grid-line,
        .exp-grid-line,
        .aboutme-grid-line,
        .help-grid-line,
        .talk-grid-line{
            display: grid;
            gap: 1rem; /* spacing between columns */
            margin-bottom: 0.2em;
            margin-left: 12rem;
        }
        .edu-grid-line {
            grid-template-columns: 210px 90px 1fr; /* adjust as needed */
        }
        .exp-grid-line {
            font-weight: bold;
            grid-template-columns: 211px 80px 1fr;
        }
        .exp-description {
            margin-left: 12rem;
            margin-bottom: 1.0em;
        }
        .aboutme-grid-line {
            grid-template-columns: 170px 400px 1fr;
        }
        .help-grid-line {
            grid-template-columns: 150px 400px 1fr;
        }
        .talk-grid-line {
            grid-template-columns: 450px 100px 1fr;
        }
        .pub-title {
            font-weight: bold;
            margin-left: 12rem;
            margin-bottom: 0.2em;
        }
        .pub-authors {
            margin-left: 12rem;
            margin-bottom: 0.2em;
        }
        .pub-venue {
            font-style: italic;
            margin-left: 12rem;
            margin-bottom: 1.0em;
        }
    </style>
</head>

<body class="terminal">
<div class="container">
    <div class="terminal-nav">
        <header class="terminal-logo">
            <div class="logo terminal-prompt">
                <!-- Hard-coded user/prompt name -->
                <span contenteditable="false">mianchu:~$</span>

                <!-- Our single contenteditable field -->
                <div id="consoleForm">
                    <div autocorrect="off"
                         autocapitalize="none"
                         spellcheck="false"
                         id="terminalInput"
                         class="placeholder"
                         contenteditable="true"
                         data-placeholder="type 'help' to show available commands"
                    ></div>
                </div>
            </div>
        </header>

        <nav class="terminal-menu">
            <ul vocab="https://schema.org/" typeof="BreadcrumbList">
                {{ range .Site.Params.navlinks }}
                <li><a href="{{ absURL .url }}" typeof="ListItem">{{ .name }}</a></li>
                {{ end }}
            </ul>
        </nav>
    </div>
</div>

<!-- We insert new outputs at the top of #echoArea -->
<div class="container {{ .Site.Params.animateStyle }}">
    <div id="echoArea" class="echo-output" style="margin-bottom: 1em;"></div>
    {{ block "main" . }}{{ end }}
    {{ partial "footer.html" . }}
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const terminalDiv = document.getElementById('terminalInput');
        const echoContainer = document.getElementById('echoArea');

        // Known commands
        const commands = ["help", "aboutme", "education", "experience", "publications", "talks", "services"];

        // On load, focus + placeholder check
        setTimeout(() => { terminalDiv.focus(); }, 50);
        document.addEventListener('click', (e) => {
            if (!terminalDiv.contains(e.target)) {
                terminalDiv.focus();
            }
        });

        // 1) CHECKING + REMOVING PLACEHOLDER

        function checkPlaceholder() {
            // Only re-add the placeholder if the content is truly empty
            if (!terminalDiv.textContent) {
                terminalDiv.classList.add('placeholder');
                terminalDiv.textContent = terminalDiv.getAttribute('data-placeholder');
            }
        }

        function removePlaceholderIfNeeded() {
            if (terminalDiv.classList.contains('placeholder')) {
                terminalDiv.classList.remove('placeholder');
                const placeholderText = terminalDiv.getAttribute('data-placeholder');
                // Remove that placeholder from the textContent
                let current = terminalDiv.textContent;
                current = current.replace(placeholderText, "");
                terminalDiv.textContent = current;
            }
        }

        // 2) AUTOCOMPLETE
        function buildAutocomplete() {
            // Skip if in placeholder mode
            if (terminalDiv.classList.contains('placeholder')) return;

            const typed = getPureTyped(); // get the raw text (incl. spaces)

            // ---- NEW CHECK: If only whitespace, don't try leftover logic at all ----
            if (!typed.trim()) {
                // typed is all spaces (or empty)
                terminalDiv.textContent = typed;  // Keep whatever spaces user typed
                placeCaretAtEnd(terminalDiv);
                return;
            }

            // 1) normal leftover logic below...
            const partial = typed.toLowerCase();
            const matches = commands.filter(cmd => cmd.toLowerCase().startsWith(partial));

            if (matches.length === 1) {
                // If typed is not the entire command => leftover
                const match = matches[0];
                if (match.toLowerCase() !== partial) {
                    const leftover = match.slice(partial.length);
                    terminalDiv.innerHTML =
                        escapeHTML(typed) + `<span class="leftover">${escapeHTML(leftover)}</span>`;
                    placeCaretAtEnd(terminalDiv);
                    return;
                }
            }

            // Otherwise => no leftover
            terminalDiv.textContent = typed;
            placeCaretAtEnd(terminalDiv);
        }


        function acceptLeftover() {
            const leftoverSpan = terminalDiv.querySelector('.leftover');
            if (!leftoverSpan) return;
            const typed = getPureTyped();
            const leftover = leftoverSpan.textContent;
            terminalDiv.textContent = typed + leftover;
            placeCaretAtEnd(terminalDiv);
        }

        // 3) PROCESS A COMMAND
        function processCommand(typed) {
            const now = new Date();
            const timestamp = formatTime(now);
            let outputHtml = ``;

            // For matching commands, we still trim + lowercase:
            const cmd = typed.trim().toLowerCase();
            switch (cmd) {
                case "help":
                    outputHtml += `
                    <div class="echo">[${escapeHTML(timestamp)}] <b>Help</b> </div>
                    <div class="line">Available commands:</div>
                    <div class="help-grid-line">
                      <div>aboutme:</div>
                      <div>show my information</div>
                    </div>

                    <div class="help-grid-line">
                      <div>experience:</div>
                      <div>show my experience</div>
                    </div>

                    <div class="help-grid-line">
                      <div>education:</div>
                      <div>show my education</div>
                    </div>

                    <div class="help-grid-line">
                      <div>publications:</div>
                      <div>show my publications</div>
                    </div>
                    <div class="help-grid-line">
                      <div>talks:</div>
                      <div>show my talks</div>
                    </div>
                    <div class="help-grid-line">
                      <div>services:</div>
                      <div>show my services</div>
                    </div>
                `;
                    break;
                case "aboutme":
                    outputHtml += `
                    <div class="echo">[${escapeHTML(timestamp)}] <b>About Me</b></div>
                    <div class="aboutme-grid-line">
                      <div>Name:</div>
                      <div>Mianchu Wang</div>
                    </div>
                    <div class="aboutme-grid-line">
                      <div>Affiliation:</div>
                      <div>University of Warwick</div>
                    </div>
                    <div class="aboutme-grid-line">
                      <div>Position:</div>
                      <div>PhD Student & Research Asssistant</div>
                    </div>
                    <div class="aboutme-grid-line">
                      <div>Research interests:</div>
                      <div>Reinforcement learning and its applications</div>
                    </div>
                    <div class="aboutme-grid-line">
                      <div>Email:</div>
                      <div>mianchu.wang [AT] warwick.ac.uk</div>
                    </div>
                     <div class="aboutme-grid-line">
                      <div>
                        <a href="https://scholar.google.com/citations?user=sk0VioYAAAAJ&hl=en" style="text-decoration: underline;">Google Scholar</a>
                      </div>
                      <div>
                        <a href="https://github.com/MianchuWang" style="text-decoration: underline;">GitHub</a>
                      </div>
                    </div>
                `;
                    break;
                case "experience":
                    outputHtml += `
                    <div class="echo">[${escapeHTML(timestamp)}] <b>Experience</b></div>
                    <div class="exp-grid-line">
                      <div>Research Assistant</div>
                      <div>2023-2025</div>
                      <div>University of Warwick</div>
                    </div>
                    <div class="exp-description">
                        * Supported by EPSRC on offline reinforcement learning methods.
                    </div>

                    <div class="exp-grid-line">
                      <div>Senior Teaching Assistant</div>
                      <div>2022-2023</div>
                      <div>University of Warwick</div>
                    </div>
                    <div class="exp-description">
                        <div>* Assisted WM391 Industrial Vision and Processing</div>
                        <div>* Assisted WM3B7 Data Science and Machine Learning</div>
                    </div>

                    <div class="exp-grid-line">
                      <div>Research Intern</div>
                      <div>2018</div>
                      <div>Chinese Academy of Sciences</div>
                    </div>
                    <div class="exp-description">
                        <div>* Have a taste of machine learning research.</div>
                    </div>
                `;
                    break;
                case "education":
                    outputHtml += `
                    <div class="echo">[${escapeHTML(timestamp)}] <b>Education</b></div>
                    <div class="edu-grid-line">
                      <div>PhD in Engineering</div>
                      <div>2020-2025</div>
                      <div>University of Warwick</div>
                    </div>
                    <div class="edu-grid-line">
                      <div>BSc in Computer Science</div>
                      <div>2016-2020</div>
                      <div>Lancaster University</div>
                    </div>
                    <div class="edu-grid-line">
                      <div>BEng in Computer Science</div>
                      <div>2016-2020</div>
                      <div>Beijing Jiaotong University</div>
                    </div>
                `;
                    break;
                case "publications":
                    outputHtml += `
                    <div class="echo">[${escapeHTML(timestamp)}] <b>Publications</b></div>

                    <div class="pub-title">Learning on One Mode: Addressing Multi-modality in Offline Reinforcement Learning</div>
                    <div class="pub-authors">Mianchu Wang, Yue Jin, Giovanni Montana</div>
                    <div class="pub-venue">International Conference on Learning Representations (ICLR), 2025</div>

                    <div class="pub-title">GOPlan: Goal-conditioned Offline Reinforcement Learning by Planning with Learned Models</div>
                    <div class="pub-authors">Mianchu Wang, Rui Yang, Xi Chen, Hao Sun, Meng Fang, Giovanni Montana</div>
                    <div class="pub-venue">Transactions on Machine Learning Research (TMLR), 2024</div>

                    <div class="pub-title">Goal-conditioned Offline Reinforcement Learning through State Space Partitioning</div>
                    <div class="pub-authors">Mianchu Wang, Yue Jin, Giovanni Montana</div>
                    <div class="pub-venue">Machine Learning, 2024</div>
                `;
                    break;
                case "talks":
                    outputHtml += `
                    <div class="echo">[${escapeHTML(timestamp)}] <b>Talks</b></div>
                    <div class="talk-grid-line">
                      <div>UK AI Conference, Birmingham</div>
                      <div>Nov 2024</div>
                    </div>
                    <div class="talk-grid-line">
                      <div>European Conference on Machine Learning, Vilnius</div>
                      <div>Sep 2024</div>
                    </div>
                    <div class="talk-grid-line">
                      <div>GCRL workshop at NeurIPS, New Orleans</div>
                      <div>Dec 2023</div>
                    </div>
                `;
                    break;
                case "services":
                    outputHtml += `
                    <div class="echo">[${escapeHTML(timestamp)}] <b>Services</b></div>
                    <div class="line"><b>Reviewer</b>: ICLR 2025, TMLR 2024-2025.</div>
                `;
                    break;
                default:
                    // If cmd is empty or something unrecognized:
                    if (cmd === "") {
                        outputHtml += `
                        <div class="echo">[${escapeHTML(timestamp)}] <b>N/A</b> </div>
                        <div class="line">No command entered.</div>
                    `;
                    } else {
                        outputHtml += `
                        <div class="echo">[${escapeHTML(timestamp)}] <b>${cmd}</b> </div>
                        <div class="line">Command not found: ${escapeHTML(typed)}</div>
                    `;
                    }
                    break;
            }

            const newBlock = document.createElement('div');
            newBlock.innerHTML = outputHtml;
            echoContainer.insertBefore(newBlock, echoContainer.firstChild);
        }

        // 4) HANDLE ENTER
        function handleEnter() {
            const typed = getPureTyped(); // includes spaces
            // If typed is truly empty string (no text at all):
            if (!typed) {
                return; // do nothing
            }
            // Clear the content
            terminalDiv.textContent = "";
            checkPlaceholder();
            processCommand(typed);
        }

        // 5) EVENT LISTENERS
        terminalDiv.addEventListener('input', () => {
            removePlaceholderIfNeeded();
            buildAutocomplete();
        });

        terminalDiv.addEventListener('keydown', (e) => {
            removePlaceholderIfNeeded()
            // We handle leftover logic in a setTimeout so we can read the new content
            // after the default key event is applied (except for Enter/Tab which we override).
            setTimeout(() => {
                // Always force caret at the end
                placeCaretAtEnd(terminalDiv);
            }, 0);

            if (e.key.length === 1 && !e.metaKey && !e.ctrlKey && !e.altKey) {
                // User typed a normal character (including space)
                const leftoverSpan = terminalDiv.querySelector('.leftover');
                if (leftoverSpan) {
                    const leftoverFirst = leftoverSpan.textContent.charAt(0);
                    // If user typed the next leftover character, remove that char from leftover
                    if (e.key.toLowerCase() === leftoverFirst.toLowerCase()) {
                        leftoverSpan.textContent = leftoverSpan.textContent.slice(1);
                        if (!leftoverSpan.textContent) {
                            leftoverSpan.remove();
                        }
                    } else {
                        // If user typed something else => remove leftover
                        leftoverSpan.remove();
                    }
                }
            } else if (e.key === 'Backspace') {
                // If leftover is present, remove it
                const leftoverSpan = terminalDiv.querySelector('.leftover');
                if (leftoverSpan) leftoverSpan.remove();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                handleEnter();
            } else if (e.key === 'Tab') {
                e.preventDefault();
                acceptLeftover();
            }
        });

        checkPlaceholder();

        // Show some initial commands as if typed on load
        processCommand("services");
        processCommand("talks");
        processCommand("publications");
        processCommand("education");
        processCommand("experience");
        processCommand("aboutme");

        // 6) HELPER FUNCTIONS

        // We do NOT trim here, so user spaces remain visible
        function getPureTyped() {
            if (terminalDiv.classList.contains('placeholder')) return "";
            const leftoverSpan = terminalDiv.querySelector('.leftover');
            let total = terminalDiv.textContent;
            if (leftoverSpan) {
                const leftover = leftoverSpan.textContent;
                // Remove leftover from the visible text if it exists
                total = total.replace(leftover, '');
            }
            return total;
        }

        function placeCaretAtEnd(el) {
            el.focus();
            if (typeof window.getSelection !== "undefined" &&
                typeof document.createRange !== "undefined") {
                const range = document.createRange();
                range.selectNodeContents(el);
                range.collapse(false);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }

        function escapeHTML(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;");
        }

        function formatTime(date) {
            function pad(n){return n<10 ? "0"+n : n;}
            const d = pad(date.getDate());
            const m = pad(date.getMonth()+1);
            const y = date.getFullYear();
            const hh = pad(date.getHours());
            const mm = pad(date.getMinutes());
            const ss = pad(date.getSeconds());
            return `${d}/${m}/${y}, ${hh}:${mm}:${ss}`;
        }
    });
</script>
</body>
</html>
